Necesito adaptar los scripts JavaScript al sistema de dashboard que tengo. El objetivo principal del proyecto es generar contratos rentables mediante el siguiente proceso:

1. Seleccionar 10 armas para crear 1 contrato y evaluar su rentabilidad

2. Ejemplo de armas a utilizar con sus especificaciones:
   - Nombre del arma | Skin | Float | Precio base
   - Ej: CZ75-Auto | Pole Position | 0.238611832261 | USD 0,4
   - Ej: CZ75-Auto | Pole Position | 0.220374569297 | USD 0,39
   - Ej: CZ75-Auto | Pole Position | 0.168953627348 | USD 0,54
   - Ej: CZ75-Auto | Pole Position | 0.238976866007 | USD 0,52
   - Ej: MAG-7 | Heat | 0.104343123734 | USD 1,97
   - Ej: CZ75-Auto | Pole Position | 0.102377697825 | USD 1,97
   - Ej: CZ75-Auto | Pole Position | 0.102111607790 | USD 1,9
   - Ej: CZ75-Auto | Pole Position | 0.093739800155 | USD 1,95
   - Ej: CZ75-Auto | Pole Position | 0.087684854865 | USD 1,99
   - Ej: CZ75-Auto | Pole Position | 0.079796582460 | USD 1,99

3. Estas armas pueden generar los siguientes contratos:
   - Arma | Colección | Grado | Probabilidad
   - Ej: FAMAS | Djinn | Chroma 2 | Classified | 33.33%
   - Ej: Galil AR | Eco | Chroma 2 | Classified | 33.33%
   - Ej: Five-SeveN | Monkey Business | Chroma 2 | Classified | 33.33%


4. Estadísticas de las armas obtenidas en los contratos:
   - Float mínimo | Float máximo | Float estimado | Precio
   - Ej: 0,00 | 1,00 | 0,143697 FN | USD 6,23
   - Ej: 0,00 | 1,00 | 0,143697 FN | USD 68,44
   - Ej: 0,00 | 1,00 | 0,143697 MW | USD 19,6


5. Datos económicos:
   - Costo total del contrato: USD 13,62
   - Precio promedio obtenido: USD 31,42
   - ROI posible: 230,71% (calculado como 13.62/31.42)


El objetivo final es desarrollar un algoritmo que:
- Analice combinaciones de armas
- Calcule la rentabilidad potencial de cada contrato
- Identifique los contratos más rentables
- Se integre con el sistema dashboard existente

El algoritmo debe considerar:
- Los floats de las armas
- Los precios de mercado
- Las probabilidades de obtención
- El cálculo preciso del ROI


en base a esto y a los js ha un prompt basico que describa todas las funciones, recuerda que usaremos la api de csfloats para obtener los precios de mercado y los datos de las armas.

Perfecto. Aquí tienes un **prompt básico en XML** para adaptar tus scripts al dashboard y construir el motor de contratos usando la **API de CSFloat** para precios/atributos (floats, seeds, etc.). Está pensado para que lo pegues en tu flujo de IA/código y te genere los módulos/funciones con las firmas y la integración mínima.

```xml
<prompt name="cs2-tradeups-adapt" version="1.0">
  <role>Principal Full-Stack Engineer (React + TS + Hono Proxy) — Especialista en contratos de CS2</role>

  <objetivo>
    Integrar en el dashboard un motor que:
    1) tome 10 armas (Nombre | Skin | Float | Precio base) desde listados CSFloat;
    2) calcule float promedio y floats resultantes por contrato;
    3) evalúe outcomes (skin objetivo, colección, grado, probabilidad);
    4) compute EV/ROI y ordene los contratos más rentables;
    5) exponga la lógica en hooks/servicios reutilizables.
  </objetivo>

  <fuentes-de-datos>
    <api>CSFloat vía proxy Hono del dashboard</api>
    <endpoints>
      <get_listings>/proxy/listings?min_float=&max_float=&market_hash_name=&def_index=&category=&paint_seed=&limit=&cursor=&sort_by=</get_listings>
      <get_listing_by_id>/proxy/listings/:id</get_listing_by_id>
    </endpoints>
    <notas>
      - Los precios llegan en centavos: convertir a USD (price_cents / 100).
      - El proxy inyecta Authorization y maneja rate limit/reintentos.
    </notas>
  </fuentes-de-datos>

  <reglas-de-negocio>
    <floats>
      - Calcular el float medio de las 10 entradas.
      - Para cada outcome (skin objetivo) con rango [min,max], estimar:
        float_estimado = clamp(avg_float * (max - min) + min, 0, 1)
        (redondeo a 6 decimales, etiquetar por wear según umbrales).
    </floats>
    <economia>
      - costo_total = suma de precios USD de las 10 entradas.
      - EV = Σ_i (prob_i * precio_outcome_i_USD).
      - ROI = (EV - costo_total) / costo_total.
      - multiplicador_retorno = EV / costo_total.
    </economia>
    <probabilidades>
      - Usar las provistas por el caller. Si no hay, asumir uniforme entre outcomes válidos del contrato.
    </probabilidades>
  </reglas-de-negocio>

  <arquitectura>
    <frontend>
      - React + TS. Estado remoto con React Query; estado local con Zustand si aplica.
      - Hooks de datos: useListings(filters), useListing(id).
      - Hook de contratos: useTradeupEngine().
      - Utilidades puras en /lib/tradeups/* (sin dependencias de UI).
    </frontend>
    <proxy>
      - Hono en :8787, rutas /proxy/*, inyecta API key, rate limiting y backoff.
    </proxy>
  </arquitectura>

  <funciones>
    <fn name="normalizeFilters" capa="frontend:utils">
      <descripcion>Normaliza filtros de UI a query de CSFloat (snake_case, arrays, rangos).</descripcion>
      <input>{ category?, def_index[]?, min_float?, max_float?, market_hash_name?, paint_seed?, limit?, cursor?, sort_by? }</input>
      <output>URLSearchParams ordenados alfabéticamente (determinismo para tests)</output>
    </fn>

    <fn name="fetchListings" capa="frontend:data">
      <descripcion>GET /proxy/listings con filtros normalizados. Controla paginación y convierte price_cents→USD.</descripcion>
      <input>Filters normalizados</input>
      <output>{ data: Listing[], cursor?: string }</output>
      <errores>Propagar 4xx; reintentos en 429/5xx (respetar Retry-After); mapear a ErrorState UX.</errores>
    </fn>

    <fn name="fetchListingById" capa="frontend:data">
      <descripcion>GET /proxy/listings/:id para completar datos (p.ej. item.id para permalink).</descripcion>
      <input>{ id: string }</input>
      <output>Listing completo</output>
    </fn>

    <fn name="avgInputFloat" capa="core:math">
      <descripcion>Promedia los 10 floats de entrada (valida exactamente 10 items).</descripcion>
      <input>float[] (largo 10)</input>
      <output>avg_float (0..1)</output>
    </fn>

    <fn name="estimateOutputFloat" capa="core:math">
      <descripcion>Aplica fórmula de trade-up: avg*(max-min)+min; clamp y redondeo a 6 decimales; etiqueta wear.</descripcion>
      <input>{ avg_float, min_float, max_float }</input>
      <output>{ float_estimado, wear_tag }</output>
    </fn>

    <fn name="computeContractOutcomes" capa="core:contracts">
      <descripcion>
        A partir de las 10 entradas y el set de outcomes posibles (skin|colección|grado|prob),
        devuelve outcomes enriquecidos con float_estimado y precio_mercado_USD.
      </descripcion>
      <input>
        - inputs: { name, skin, float, price_usd } x10
        - outcomes_base: { arma, skin, coleccion, grado, prob, float_min, float_max }[]
      </input>
      <output>
        { arma, skin, coleccion, grado, prob, float_estimado, wear_tag, precio_mercado_usd }[]
      </output>
      <notas>
        - Obtiene precio_mercado vía CSFloat (listing más representativo o precio mediano si se dispone).
      </notas>
    </fn>

    <fn name="computeEVandROI" capa="core:economia">
      <descripcion>Calcula EV, ROI, multiplicador y punto de equilibrio.</descripcion>
      <input>{ outcomes_enriquecidos[], costo_total_usd }</input>
      <output>{ ev_usd, roi, multiple, break_even_usd }</output>
    </fn>

    <fn name="rankContracts" capa="core:economia">
      <descripcion>Ordena contratos por ROI (desc), luego por EV, luego por varianza de precios (asc).</descripcion>
      <input>contratos[] con métricas</input>
      <output>contratos[] ordenados</output>
    </fn>

    <fn name="buildCsfloatPermalink" capa="frontend:utils">
      <descripcion>Devuelve permalink “/item/&lt;ID&gt;” o fallback “/checker?inspect=&lt;inspect_link&gt;”.</descripcion>
      <input>listing u objeto con { id?, inspect_link? }</input>
      <output>string URL</output>
    </fn>

    <fn name="useTradeupEngine" capa="frontend:hook">
      <descripcion>
        Hook que orquesta: fetchListings → selección de 10 items → computeContractOutcomes → computeEVandROI →
        ranking. Expone estados (loading, error) y resultados memoizados.
      </descripcion>
      <input>UI filters + outcomes_base (con probabilidades)</input>
      <output>{ contratos, isLoading, error, refetch }</output>
    </fn>
  </funciones>

  <validaciones>
    - Exactly 10 inputs; floats 0..1; precios ≥ 0.
    - Precios en USD derivados de centavos.
    - Manejo de 4xx sin reintentos; 429/5xx con backoff exponencial.
  </validaciones>

  <entregables>
    - /lib/tradeups/math.ts (avgInputFloat, estimateOutputFloat)
    - /lib/tradeups/econ.ts (computeEVandROI, rankContracts)
    - /lib/api/listings.ts (fetchListings, fetchListingById)
    - /lib/utils/url.ts (buildCsfloatPermalink)
    - /hooks/useTradeupEngine.ts (composición)
    - Tests unitarios (Vitest) y mocks de proxy/CSFloat.
  </entregables>
</prompt>
```

**Notas y referencias rápidas (para el implementador):**

* **Fórmula de float estimado y promedio**: tu `float.js` ya define el promedio de 10 entradas y la transformación `avg*(max-min)+min` con clamp/redondeo; replica esa lógica como función pura. &#x20;
* **Cálculo de outcomes/probabilidades**: tu `tradeups.js` arma resultados por colección/grado con probabilidad declarada; úsalo como guía para `computeContractOutcomes`. &#x20;
* **Proxy + endpoints del dashboard**: consume `GET /proxy/listings` y `GET /proxy/listings/:id`; el proxy inyecta `Authorization`, hace rate-limit y backoff. &#x20;
* **Precios en centavos (¡convertir a USD!)**: la doc del proyecto lo exige para evitar errores en EV/ROI.&#x20;
* **Campos críticos del listing (web/TS)**: `item.float_value`, `item.paint_seed`, `inspect_link` (útil para permalink fallback).&#x20;
* **Permalink público**: preferir `/item/<ID>`; fallback `/checker?inspect=<inspect_link>`.&#x20;
* **Errores, retries y UX**: 429/5xx con backoff exponencial y respeto de `Retry-After`; mapear a estados UX con mensajes claros.  &#x20;
* **Testing recomendado**: Vitest (frontend/proxy), pytest/respx (CLI) con objetivos de cobertura fijados. &#x20;

¿Quieres que te lo convierta en un **prompt “avanzado”** con ejemplos de I/O, contratos de tipos (TS) y tests de aceptación (Vitest) listos para pegar?
